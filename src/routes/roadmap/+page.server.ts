// FLAG: this file was mostly generated by AI as idk how to grab issues from github! (hopefully someone can improve this)

import { env } from "$env/dynamic/private";
import type { PageServerLoad } from "./$types";

type GitHubLabel = {
	name: string;
	color?: string;
	description?: string | null;
};

type GitHubIssue = {
	id: number;
	number: number;
	title: string;
	html_url: string;
	repository_url: string;
	state: "open" | "closed";
	labels: Array<GitHubLabel | string>;
	updated_at: string;
};

type RoadmapBuckets = {
	now: GitHubIssue[];
	next: GitHubIssue[];
	later: GitHubIssue[];
	uncategorized: GitHubIssue[];
};

function normalizeLabels(labels: Array<GitHubLabel | string>): string[] {
	return labels
		.map((l) => (typeof l === "string" ? l : l.name))
		.filter(Boolean)
		.map((n) => n.toLowerCase());
}

export const load: PageServerLoad = async ({ fetch }) => {
	// Search all open issues across the org; adjust per_page if needed
	const org = env.GITHUB_ORG || "nook-browser";
	const token = env.GITHUB_TOKEN;
	const url = `https://api.github.com/search/issues?q=org:${org}+is:issue+is:open&sort=updated&order=desc&per_page=100`;

	try {
		const headers: Record<string, string> = {
			Accept: "application/vnd.github+json",
		};
		if (token) {
			headers.Authorization = `Bearer ${token}`;
			headers["X-GitHub-Api-Version"] = "2022-11-28";
			headers["User-Agent"] = "nook-browser-roadmap";
		}

		const res = await fetch(url, { headers });

		if (!res.ok) {
			return {
				ok: false,
				status: res.status,
				error: `Failed to fetch GitHub issues (${res.status})`,
			};
		}

		const data = (await res.json()) as { items: GitHubIssue[] };
		const items = data.items || [];

		const buckets: RoadmapBuckets = {
			now: [],
			next: [],
			later: [],
			uncategorized: [],
		};

		for (const issue of items) {
			const labelNames = normalizeLabels(issue.labels);
			if (labelNames.includes("now")) {
				buckets.now.push(issue);
			} else if (labelNames.includes("next")) {
				buckets.next.push(issue);
			} else if (labelNames.includes("later")) {
				buckets.later.push(issue);
			} else {
				buckets.uncategorized.push(issue);
			}
		}

		// Sort each bucket by most recently updated
		for (const key of Object.keys(buckets) as Array<keyof RoadmapBuckets>) {
			buckets[key].sort(
				(a, b) =>
					new Date(b.updated_at).getTime() - new Date(a.updated_at).getTime(),
			);
		}

		// Collect distinct labels for filtering UI
		const distinctLabels = Array.from(
			new Set(
				items
					.flatMap((i) => normalizeLabels(i.labels))
					.filter((n) => !["now", "next", "later"].includes(n)),
			),
		).sort();

		return {
			ok: true,
			buckets,
			labels: distinctLabels,
		};
	} catch (err) {
		return {
			ok: false,
			status: 500,
			error: "Unexpected error fetching roadmap",
			details: err instanceof Error ? err.message : String(err),
		};
	}
};
